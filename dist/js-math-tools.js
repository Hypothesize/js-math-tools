(()=>{var He=(n=>typeof require!="undefined"?require:typeof Proxy!="undefined"?new Proxy(n,{get:(e,t)=>(typeof require!="undefined"?require:e)[t]}):n)(function(n){if(typeof require!="undefined")return require.apply(this,arguments);throw new Error('Dynamic require of "'+n+'" is not supported')});var c=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports);var h=c((Ol,St)=>{function Po(n){return typeof n=="number"&&!isNaN(n)}St.exports=Po});var m=c((Al,Mt)=>{Mt.exports=function(n,e){if(!n)throw new Error(e)}});var g=c((El,jt)=>{function Vo(n){return n===null||typeof n=="undefined"}jt.exports=Vo});var d=c((Il,Yt)=>{function _o(n){return n instanceof Array}Yt.exports=_o});var T=c((Sl,Ct)=>{var Ut=m(),Bo=g(),kt=d();function zt(n){Ut(!Bo(n),"You must pass one array into the `flatten` function!"),Ut(kt(n),"The `flatten` function only works on arrays!");let e=[];return n.forEach(function(t){kt(t)?e=e.concat(zt(t)):e.push(t)}),e}Ct.exports=zt});var B=c((Ml,$t)=>{var Ro=T(),Jo=h();function Ko(n){try{let e=Ro(n),t=-1/0;for(let r=0;r<e.length;r++){if(!Jo(e[r]))return NaN;e[r]>t&&(t=e[r])}return t===-1/0?NaN:t}catch{return NaN}}$t.exports=Ko});var R=c((jl,Pt)=>{function Lo(n){return typeof n=="function"}Pt.exports=Lo});var b=c((Yl,Vt)=>{var De=m(),Wo=g(),Fe=d(),Ho=B(),Do=R();function Fo(n){return De(!Wo(n),"You must pass a function into the `vectorize` function!"),De(Do(n),"You must pass a function into the `vectorize` function!"),function e(){if(Object.keys(arguments).map(r=>Fe(arguments[r])).indexOf(!0)>-1){let r=[],s=Object.keys(arguments).filter(i=>Fe(arguments[i])).map(i=>arguments[i].length),o=Ho(s);s.forEach(i=>{De(i===o,"If using arrays for all arguments to this function, then the arrays must all have equal length!")});for(let i=0;i<o;i++){let u=Object.keys(arguments).map(a=>Fe(arguments[a])?arguments[a][i]:arguments[a]);r.push(e(...u))}return r}else return n(...arguments)}}Vt.exports=Fo});var Xe=c((Ul,_t)=>{var Xo=h(),Go=b();function Qo(n){try{return Xo(n)?Math.abs(n):NaN}catch{return NaN}}_t.exports=Go(Qo)});var oe=c((kl,Bt)=>{var Zo=h(),ei=b();function ti(){try{let n=0,e=Object.values(arguments);for(let t=0;t<e.length;t++){if(!Zo(e[t]))return NaN;n+=e[t]}return n}catch{return NaN}}Bt.exports=ei(ti)});var A=c((zl,Kt)=>{var Ne=m(),ni=g(),Rt=d(),ri=B();function Jt(n){Ne(!ni(n),"You must pass an array into the `shape` function!"),Ne(Rt(n),"You must pass an array into the `shape` function!");let e=[n.length],t=n.map(r=>Rt(r));if(t.indexOf(!0)>-1){Ne(t.indexOf(!1)<0,"The array passed into the `shape` function has some children that are not themselves arrays!");let r=n.map(o=>o.length),s=ri(r);r.forEach(function(o){Ne(o===s,"The array passed into the `shape` function has some children of inconsistent length!")}),e=e.concat(Jt(n[0]))}return e}Kt.exports=Jt});var ie=c((Cl,Wt)=>{var Lt=m(),si=g(),oi=d();function ii(n){Lt(!si(n),"You must pass an array into the `reverse` function!"),Lt(oi(n),"You must pass an array into the `reverse` function!");let e=[];for(let t=n.length-1;t>=0;t--)e.push(n[t]);return e}Wt.exports=ii});var k=c(($l,Dt)=>{var ue=m(),ui=g(),ai=d(),ci=h(),li=T(),ae="You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";function Ht(n,e){if(e||(ue(!ui(n),ae),ai(n)||(n=[n]),n=li(n),ue(n.length>0,ae),n.forEach(t=>{ue(ci(t),ae),ue(parseInt(t)===t,ae),ue(t>=0,ae)})),n.length===1){let t=[];for(let r=0;r<n[0];r++)t.push(void 0);return t}else{let t=[];for(let r=0;r<n[0];r++)t.push(Ht(n.slice(1),!0));return t}}Dt.exports=Ht});var D=c((Pl,Xt)=>{var Ge=m(),fi=g(),hi=d(),mi=A(),Ft=ie(),di=k();function pi(n){Ge(!fi(n),"You must pass an array into the `transpose` function!"),Ge(hi(n),"You must pass an array into the `transpose` function!");let e=mi(n);if(Ge(e.length<=2,"I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!"),e.length===1)return Ft(n);if(e.length===2){let t=di(Ft(e));for(let r=0;r<e[0];r++)for(let s=0;s<e[1];s++)t[s][r]=n[r][s];return t}}Xt.exports=pi});var Ze=c((Vl,tn)=>{var j=m(),Gt=g(),Qt=d(),gi=h(),Zt=A(),Qe=D();function en(n,e,t=0){j(!Gt(n),"You must pass two arrays into the `append` function!"),j(!Gt(e),"You must pass two arrays into the `append` function!"),j(Qt(n),"You must pass two arrays into the `append` function!"),j(Qt(e),"You must pass two arrays into the `append` function!"),j(gi(t),"The `axis` argument to the `append` function must be 0 or 1!"),j(t>=0&&t<2,"The `axis` argument to the `append` function must be 0 or 1!"),j(parseInt(t)===t,"The `axis` argument to the `append` function must be 0 or 1!");let r=Zt(n),s=Zt(e);j(r.length===s.length,"The two arrays passed into the `append` function must have the same number of dimensions!"),j(r.length<3&&s.length<3,"The two arrays passed into the `append` function must be 1- or 2-dimensional!");for(let o=0;o<r.length;o++)o!==t&&j(r[o]===s[o],`The two arrays passed into the \`append\` function must have the same shapes along all axes *except* the axis along which they're being appended! (${r[o]} != ${s[o]})`);if(j(t<r.length,"The axis argument you passed into the `append` function is out of bounds for the array!"),r.length===0)return[];if(r.length===1)return n.concat(e);if(r.length===2){if(t===0){let o=[];for(let i=0;i<r[0];i++)o.push(n[i]);for(let i=0;i<s[0];i++)o.push(e[i]);return o}else if(t===1)return Qe(en(Qe(n),Qe(e),0))}}tn.exports=en});var z=c((_l,nn)=>{var yi=b();function qi(n,e){try{return e(n)}catch{return NaN}}nn.exports=yi(qi)});var sn=c((Bl,rn)=>{var bi=h(),Ni=b();function wi(n){try{return bi(n)?Math.acos(n):NaN}catch{return NaN}}rn.exports=Ni(wi)});var un=c((Rl,on)=>{var xi=h(),vi=b();function Ti(n){try{return xi(n)?Math.asin(n):NaN}catch{return NaN}}on.exports=vi(Ti)});var cn=c((Jl,an)=>{var Oi=h(),Ai=b();function Ei(n){try{return Oi(n)?Math.atan(n):NaN}catch{return NaN}}an.exports=Ai(Ei)});var F=c((Ll,fn)=>{var Kl=d();function ln(n,e){let t=typeof n;if(t!==typeof e)return!1;if(t==="undefined")return!0;if(t==="boolean"||t==="number"||t==="bigint"||t==="string"||t==="function")return n===e;if(t==="object"){if(n===null||e===null)return n===null&&e===null;{let s=Object.keys(n),o=Object.keys(e);if(s.length!==o.length)return!1;for(let i=0;i<s.length;i++){let u=s[i];if(!e.hasOwnProperty(u)||!ln(n[u],e[u]))return!1}return!0}}}fn.exports=ln});var ce=c((Wl,gn)=>{var hn=m(),Ii=g(),mn=d(),et=A(),dn=F();function pn(n,e,t){if(hn(!Ii(n),"You must pass an array and a value into the `indexOf` function!"),hn(mn(n),"You must pass an array and a value into the `indexOf` function!"),et(n).length===1||mn(e)&&dn(et(n[0]),et(e))){for(let r=0;r<n.length;r++){let s=n[r];if(dn(s,e)&&(t?s===e:!0))return[r]}return null}else for(let r=0;r<n.length;r++){let s=n[r],o=pn(s,e);if(o)return[r].concat(o)}return null}gn.exports=pn});var qn=c((Hl,yn)=>{var Si=ce(),Mi=B();function ji(n){try{return Si(n,Mi(n))}catch{return NaN}}yn.exports=ji});var we=c((Dl,bn)=>{var Yi=T(),Ui=h();function ki(n){try{let e=Yi(n),t=1/0;for(let r=0;r<e.length;r++){if(!Ui(e[r]))return NaN;e[r]<t&&(t=e[r])}return t===1/0?NaN:t}catch{return NaN}}bn.exports=ki});var wn=c((Fl,Nn)=>{var zi=ce(),Ci=we();function $i(n){try{return zi(n,Ci(n))}catch{return NaN}}Nn.exports=$i});var vn=c((Xl,xn)=>{var Pi=h(),Vi=b();function _i(n){try{return Pi(n)?Math.ceil(n):NaN}catch{return NaN}}xn.exports=Vi(_i)});var An=c((Gl,On)=>{var Bi=g(),Ri=Xe(),Ji=b(),Tn=h();function Ki(n,e){try{if(!Tn(n))return NaN;if(Bi(e))e=1e-10;else if(!Tn(e))return NaN;return Ri(n)<e?0:n}catch{return NaN}}On.exports=Ji(Ki)});var In=c((Ql,En)=>{var tt=h(),Li=b();function Wi(n,e,t){try{return tt(n)?tt(e)?tt(t)?n<e?e:n>t?t:n:NaN:NaN:NaN}catch{return NaN}}En.exports=Li(Wi)});var le=c((Zl,Sn)=>{var Hi=h(),Di=T();function Fi(n){try{let e=Di(n),t=0;for(let r=0;r<e.length;r++){if(!Hi(e[r]))return NaN;t+=e[r]}return t/e.length}catch{return NaN}}Sn.exports=Fi});var xe=c((ef,Mn)=>{var Xi=le(),Gi=T(),Qi=h();function Zi(n){try{let e=Gi(n),t=Xi(e),r=0;for(let s=0;s<e.length;s++){if(!Qi(e[s]))return NaN;r+=(e[s]-t)*(e[s]-t)}return r/e.length}catch{return NaN}}Mn.exports=Zi});var kn=c((tf,Un)=>{var jn=le(),Yn=xe();function eu(n,e){try{let t=jn(n),r=jn(e),s=Math.sqrt((Yn(n)+Yn(e))/2);return(t-r)/s}catch{return NaN}}Un.exports=eu});var Pn=c((nf,$n)=>{var zn=d(),tu=h(),ve=m();function Cn(n,e){if(ve(zn(n),"The `combine` function only works on arrays!"),ve(tu(e),"`r` must be a whole number!"),e>n.length)return[n];if(e<=0)return[[]];if(ve(e===parseInt(e),"`r` must be a whole number!"),n.length<2)return n;let t=[];return n.forEach((r,s)=>{ve(!zn(r),"It is not recommended to get combinations of arrays of arrays. Weird things happen, and I haven't figured out how to account for such a scenario yet. A possible workaround is: convert each sub-array to a string (using `JSON.stringify`), get the combinations using the array of strings, and then convert each string in each combination back to a sub-array (using `JSON.parse`).");let o=n.slice(s+1);if(o.length<e-1)return;Cn(o,e-1).forEach(u=>{t.push([r].concat(u))})}),t}$n.exports=Cn});var X=c((sf,Vn)=>{var rf=m(),nu=g(),ru=d();function nt(n){if(typeof n=="object"){if(nu(n))return n;if(ru(n))return n.map(nt);{let e={};return Object.keys(n).forEach(function(t){e[t]=nt(n[t])}),e}}else return n}Vn.exports=nt});var rt=c((of,Rn)=>{var _n=le(),Bn=g();function su(n,e){try{let t=_n(n),r=_n(e),s=Math.max(n.length,e.length),o=0;for(let i=0;i<s;i++){if(Bn(n[i]))return NaN;if(Bn(e[i]))return NaN;o+=(n[i]-t)*(e[i]-r)}return o/n.length}catch{return NaN}}Rn.exports=su});var Te=c((uf,Jn)=>{var ou=h(),iu=b();function uu(n){try{return ou(n)?Math.sqrt(n):NaN}catch{return NaN}}Jn.exports=iu(uu)});var Oe=c((af,Kn)=>{var au=Te(),cu=xe();function lu(n){try{return au(cu(n))}catch{return NaN}}Kn.exports=lu});var Hn=c((cf,Wn)=>{var fu=rt(),Ln=Oe();function hu(n,e){try{return fu(n,e)/(Ln(n)*Ln(e))}catch{return NaN}}Wn.exports=hu});var Fn=c((lf,Dn)=>{var mu=h(),du=b();function pu(n){try{return mu(n)?Math.cos(n):NaN}catch{return NaN}}Dn.exports=du(pu)});var L=c((ff,Gn)=>{var Xn=m(),gu=g(),yu=d(),qu=T();function bu(n){Xn(!gu(n),"You must pass an array into the `set` function!"),Xn(yu(n),"You must pass an array into the `set` function!");let e=[],t={};return qu(n).forEach(r=>{let s=typeof r=="undefined"?"undefined":typeof r=="function"?r.toString():JSON.stringify(r);t[s]||e.push(r),t[s]=!0}),e}Gn.exports=bu});var Ae=c((hf,nr)=>{var Qn=m(),Zn=g(),er=d(),tr=T(),Nu=F(),wu=L();function xu(n,e){Qn(!Zn(n),"You must pass an array and some items to count into the `count` function!"),Qn(er(n),"You must pass an array and some items to count into the `count` function!");let t=tr(n);return e=Zn(e)?wu(n):e,er(e)?tr(e).map(function(r){let s=t.filter(o=>Nu(r,o)).length;return{item:r,count:s}}):t.filter(r=>r===e).length}nr.exports=xu});var G=c((mf,ur)=>{var fe=m(),rr=d(),sr=h(),vu=A(),or=T(),Tu=n=>n.reduce((e,t)=>e*t);function ir(n,e){if(fe(rr(n),"The first argument passed into the `reshape` function must be an array!"),sr(e)&&(e=[e]),fe(rr(e),"The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),fe(vu(e).length===1,"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),e.forEach(o=>{fe(sr(o)&&parseInt(o)===o&&o>0,"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!")}),e.length<=1)return or(n);let t=or(n);fe(Tu(e)===t.length,"The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!");let r=[],s=parseInt(t.length/e[0]);for(let o=0;o<e[0];o++){let i=t.slice(o*s,(o+1)*s);r.push(ir(i,e.slice(1)))}return r}ur.exports=ir});var Q=c((gf,pr)=>{var df=k(),pf=z(),ar=g(),Ou=m(),cr=h(),lr=X(),Au=G(),fr=Math.pow(2,64),N=[];mr(parseInt(Math.random()*fr));function Eu(n,e){n=E(n);function t(){n+=E("0x9e3779b97f4a7c15");let s=lr(n);return s=(s^s>>30n)*E("0xbf58476d1ce4e5b9"),s=(s^s>>27n)*E("0x94d049bb133111eb"),s^s>>31n}let r=[];for(let s=0;s<e;s++)r.push(t());return r}function E(n){return BigInt.asUintN(64,BigInt(n))}function hr(n,e){return n=E(n),e=BigInt(e),E(E(n<<e)|E(n>>E(64n-e)))}function mr(n){if(ar(n))return lr(N);{Ou(cr(n),"If passing a value into the `seed` function, then that value must be an integer!");let e=Eu(parseInt(n),4);N[0]=e[0],N[1]=e[1],N[2]=e[2],N[3]=e[3]}}function dr(){let n=E(hr(N[0]+N[3],23)+N[0]),e=E(N[1]<<17n);return N[2]=E(N[2]^N[0]),N[3]=E(N[3]^N[1]),N[1]=E(N[1]^N[2]),N[0]=E(N[0]^N[3]),N[2]=E(N[2]^e),N[3]=hr(N[3],45),parseInt(n)/fr}function Iu(n){if(ar(n))return dr();cr(n)&&(n=[n]);let e=[],t=1;n.forEach(r=>t*=r);for(let r=0;r<t;r++)e.push(dr());return Au(e,n)}pr.exports={random:Iu,seed:mr}});var Ee=c((yf,yr)=>{var gr=m(),Su=d(),Mu=g(),ju=h(),Yu=A();function Uu(n){return gr(Su(n),"The value passed into the `dropNaN` function must be a one-dimensional array!"),gr(Yu(n).length===1,"The value passed into the `dropNaN` function must be a one-dimensional array"),n.filter(e=>!Mu(e)&&ju(e))}yr.exports=Uu});var Ie=c((qf,qr)=>{function ku(n){return typeof n=="boolean"}qr.exports=ku});var Se=c((bf,br)=>{function zu(n){return typeof n=="string"}br.exports=zu});var Z=c((Nf,Nr)=>{var st=m(),ot=g(),it=h(),Cu=ie();function $u(n,e,t=1){st(!ot(n)&&!ot(e)&&!ot(t),"You must pass two numbers and optionally a step value to the `range` function!"),st(it(n)&&it(e)&&it(t),"You must pass two numbers and optionally a step value to the `range` function!"),st(t>0,"The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)");let r=!1;if(n>e){r=!0;let o=n;n=e+t,e=o+t}let s=[];for(let o=n;o<e;o+=t)s.push(o);return r&&(s=Cu(s)),s}Nr.exports=$u});var ee=c((wf,xr)=>{var ut=m(),wr=g(),Pu=d(),Vu=R();function _u(n,e){return n<e?-1:n>e?1:0}function Bu(n,e){wr(e)&&(e=_u),ut(!wr(n),"You must pass an array into the `sort` function!"),ut(Pu(n),"You must pass an array into the `sort` function!"),ut(Vu(e),"The second parameter of the `sort` function must be a comparison function!");let t=n.slice();return t.sort(e),t}xr.exports=Bu});var Ye=c((vf,Er)=>{var q=m(),Me=d(),W=g(),te=A(),je=D(),he=Z(),at=h(),me=Se(),xf=z(),Ru=R(),Ju=k(),ct=X(),Ku=L(),vr=ie(),Tr=ee(),Or=Ie();function Lu(n){return at(n)&&parseInt(n)===n}function Wu(n){return Lu(n)&&n>=0}function Ar(n,e){q(at(n),"The `leftPad` function only works on numbers!");let t=n.toString();for(;t.length<e;)t="0"+t;return t}var C=class{constructor(e){let t=this;if(t.name="data",Object.defineProperty(t,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(t,"values",{configurable:!0,enumerable:!0,get(){return t._values},set(r){q(Me(r),"The new values must be a 1-dimensional array!");let s=te(r);q(s.length===1,"The new array of values must be 1-dimensional!"),s[0]<t._index.length?t._index=t._index.slice(0,s[0]):s[0]>t._index.length&&(t._index=t._index.concat(he(t._index.length,s[0]).map(o=>"row"+Ar(o,(r.length-1).toString().length)))),t._values=r}}),Object.defineProperty(t,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(t,"index",{configurable:!0,enumerable:!0,get(){return t._index},set(r){q(Me(r),"The new index must be a 1-dimensional array of strings!"),q(r.length===t.shape[0],"The new index must be the same length as the old index!"),q(te(r).length===1,"The new index must be a 1-dimensional array of strings!"),r.forEach(s=>{q(me(s),"All of the row names must be strings!")}),t._index=r}}),e){let r=te(e);q(r.length===1,"The `data` array passed into the constructor of a DataFrame must be 1-dimensional!"),t.values=e}}get shape(){return te(this.values)}isEmpty(){return this.values.filter(t=>!W(t)).length===0}clear(){let e=this,t=e.copy();return t.values=Ju(t.shape),t.index=e.index,t}get(e){let t=this;(me(e)||at(e))&&(e=[e]);let r=Ku((e||[]).map(s=>typeof s));return q(r.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===1&&q(r[0]==="string"||r[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===2&&(q(r.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),q(r.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),W(e)||(e=e.map(s=>{if(typeof s=="string")return q(t.index.indexOf(s)>-1,`Index "${s}" does not exist!`),s;if(typeof s=="number")return q(s>=0,`Index ${s} is out of bounds!`),q(parseInt(s)===s,"Indices must be integers!"),q(s<t.index.length,`Index ${s} is out of bounds!`),t.index[s]})),t.getSubsetByNames(e)}getSubsetByNames(e){let t=this;W(e)&&(e=t.index),q(Me(e),"The `indices` array must be a 1-dimensional array of strings."),q(te(e).length===1,"The `indices` array must be a 1-dimensional array of strings."),q(e.length>0,"The `indices` array must contain at least one index name."),e.forEach(o=>{q(me(o),"The `indices` array must contain only strings."),q(t.index.indexOf(o)>-1,`The name "${o}" does not exist in the index.`)});let r=e.map(o=>t.values[t.index.indexOf(o)]);if(r.length===1)return r[0];let s=new C(r);return s.index=e,s.name=t.name,s}getSubsetByIndices(e){let t=this,r=t.shape;W(e)&&(e=he(0,r[0])),q(Me(e),"The `indices` array must be 1-dimensional array of whole numbers."),q(te(e).length===1,"The `indices` array must be a 1-dimensional array of whole numbers."),q(e.length>0,"The `indices` array must contain at least one index."),e.forEach(o=>{q(Wu(o),"The `indices` array must be a 1-dimensional array of whole numbers."),q(o<t.index.length,`The row index ${o} is out of bounds.`)});let s=e.map(o=>t.index[o]);return t.getSubsetByNames(s)}loc(e){return this.getSubsetByNames(e)}iloc(e){return this.getSubsetByIndices(e)}reverse(){let e=this,t=new C(vr(e.values));return t.index=vr(e.index),t.name=e.name,t}resetIndex(){let e=this,t=e.copy();return t.index=he(0,e.shape[0]).map(r=>"row"+Ar(r,(t.index.length-1).toString().length)),t}copy(){let e=this,t=new C(ct(e.values));return t.index=e.index.slice(),t.name=e.name,t}apply(e){q(Ru(e),"The parameter to the `apply` method must be a function.");let r=this.copy();return r.values=r.values.map((s,o)=>e(s,r.index[o])),r}dropMissing(e,t){let s=this.copy(),o=[];return s.values=s.values.filter((i,u)=>W(i)?!1:(o.push(s.index[u]),!0)),s.index=o,s}toObject(){let e=this,t={};return t[e.name]={},e.index.forEach((r,s)=>{t[e.name][r]=e.values[s]}),t}print(){let e=this,t=e.copy(),r=typeof window=="undefined"?20:10;if(t.index.length>r){t=t.get(he(0,r/2).concat(he(t.index.length-r/2,t.index.length)));let o=ct(t.index);o.splice(parseInt(o.length/2),0,"..."),t.values.push("..."),t.index.push("..."),t=t.get(o)}let s={};return t.values.forEach((o,i)=>{let u={};u[t.name]=o,s[t.index[i]]=u}),console.table(s),e}sort(e){q(Or(e)||me(e)||W(e),"The `sort` method can take an optional parameter that's either a string representing a direction ('ascending' or 'descending') or a boolean representing whether or not the direction is ascending (true or false).");let t=!0;W(e)&&(t=!0),me(e)&&(e=e.trim().toLowerCase(),q(e==="ascending"||e==="descending","The `sort` method can take an optional parameter that's either a string representing a direction ('ascending' or 'descending') or a boolean representing whether or not the direction is ascending (true or false)."),t=e==="ascending"),Or(e)&&(t=e);let r=this,s=je([r.values,r.index]);s=je(Tr(s,(i,u)=>{if(i[0]===u[0])return 0;if(i[0]<u[0])return t?-1:1;if(i[0]>u[0])return t?1:-1}));let o=new C(s[0]);return o.index=s[1],o.name=r.name,o}sortByIndex(){let e=this,t=je([e.values,e.index]);t=je(Tr(t,(s,o)=>{if(s[1]===o[1])return 0;if(s[1]<o[1])return-1;if(s[1]>o[1])return 1}));let r=new C(t[0]);return r.index=t[1],r.name=e.name,r}filter(e){let t=this,r=t.copy(),s=ct(r.index),o=[],i=r.values.filter((u,a)=>{let l=e(u,a,r.values);return l||o.push(r.index[a]),l});return o.forEach(u=>{s.splice(s.indexOf(u),1)}),i.length===0?(r=new C,r.name=t.name,r):(r.values=i,r.index=s,r)}};Er.exports=C});var lt=c((Af,Ur)=>{var{random:Hu}=Q(),Tf=z(),f=m(),Y=X(),Ir=Ae(),Du=Ee(),$=T(),O=d(),H=Ie(),Sr=F(),Mr=R(),P=h(),I=Se(),x=g(),Fu=B(),Of=we(),Xu=k(),M=Z(),S=Ye(),jr=L(),v=A(),Gu=ee(),de=D();function pe(n){let e="abcdefghijklmnopqrstuvwxyz1234567890",t="";for(let r=0;r<n;r++)t+=e[parseInt(Math.random()*e.length)];return t}function Qu(n){return P(n)&&parseInt(n)===n}function Ue(n){return Qu(n)&&n>=0}function Zu(n){return n instanceof Object&&!O(n)}function ne(n){return n instanceof S}function ea(n){let e=/"(.*?)"/g,t=n.match(e),r=n.slice();return t&&t.forEach(s=>{r=r.replace(s,`\u201C${s.substring(1,s.length-1)}\u201D`)}),e=/'(.*?)'/g,t=n.match(e),t&&t.forEach(s=>{r=r.replace(s,`\u2018${s.substring(1,s.length-1)}\u2019`)}),`"${r}"`}function ke(n,e){f(P(n),"The `leftPad` function only works on numbers!");let t=n.toString();for(;t.length<e;)t="0"+t;return t}function Yr(n){let e={};return $(n).forEach((t,r)=>{e[t]=r}),e}function re(n){return Object.keys(n).sort((e,t)=>n[e]-n[t])}var w=class{constructor(e){let t=this;if(Object.defineProperty(t,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(t,"values",{configurable:!0,enumerable:!0,get(){return t._values},set(r){f(O(r),"The new values must be a 2-dimensional array!");let s=v(r);f(s.length===2,"The new array of values must be 2-dimensional!"),s[0]<t._index.length?t._index=t._index.slice(0,s[0]):s[0]>t._index.length&&(t._index=t._index.concat(M(t._index.length,s[0]).map(o=>"row"+ke(o,(s[0]-1).toString().length)))),s[1]<t._columns.length?t._columns=t._columns.slice(0,s[1]):s[1]>t._columns.length&&(t._columns=t._columns.concat(M(t._columns.length,s[1]).map(o=>"col"+ke(o,(s[1]-1).toString().length)))),t._values=r}}),Object.defineProperty(t,"_columns",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(t,"columns",{configurable:!0,enumerable:!0,get(){return t._columns},set(r){f(O(r),"The new columns list must be a 1-dimensional array of strings!"),f(r.length===t.shape[1],"The new columns list must be the same length as the old columns list!"),f(v(r).length===1,"The new columns list must be a 1-dimensional array of strings!"),r=r.map(o=>(typeof o!="string"&&(o=JSON.stringify(o)||o.toString()),o.trim().length===0?"untitled_"+pe(8):o.trim()));let s=(()=>{let o=Ir(r),i={};return o.forEach(u=>{i[u.item]=u.count}),i})();r=r.map(o=>s[o]>1?o+"_"+pe(8):o),t._columns=r}}),Object.defineProperty(t,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(t,"index",{configurable:!0,enumerable:!0,get(){return t._index},set(r){f(O(r),"The new index must be a 1-dimensional array of strings!"),f(r.length===t.shape[0],"The new index must be the same length as the old index!"),f(v(r).length===1,"The new index must be a 1-dimensional array of strings!"),r=r.map(o=>(typeof o!="string"&&(o=JSON.stringify(o)||o.toString()),o.trim().length===0?"untitled_"+pe(8):o.trim()));let s=(()=>{let o=Ir(r),i={};return o.forEach(u=>{i[u.item]=u.count}),i})();r=r.map(o=>s[o]>1?o+"_"+pe(8):o),t._index=r}}),f(x(e)||e instanceof Object,"The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values."),e)if(O(e)){let r=v(e);f(r.length===2,"The `data` array passed into the constructor of a DataFrame must be 2-dimensional!"),t.values=e}else{t._columns=Object.keys(e);let r=[];t._columns.forEach(o=>{let i=e[o];r.push(i)}),t._values=de(r);let s=v(t.values);t._index=M(0,s[0]).map(o=>"row"+ke(o,(s[0]-1).toString().length))}}static async fromCSV(e,t){t=t||{};let r;try{r=await(await fetch(e)).text()}catch{}try{let y=He("fs"),_=t.encoding||"utf8";r=y.readFileSync(e,_)}catch{}let o=r.split(`
`).filter(y=>y.length>0).map(y=>{let _={},Ke=/"(.*?)"/g;return(y.match(Ke)||[]).forEach(U=>{let Le=pe(32);y=y.replaceAll(U,Le),_[Le]=U}),y.split(",").map((U,Le)=>{U=_[U]||U;try{let We=JSON.parse(U);return O(We)?U:We}catch{return U}})}),i=Fu(o.map(y=>y.length));o=o.map(y=>(y.length=i,y));let u,a,l=H(t.hasHeaderRow)?t.hasHeaderRow:!0,p=H(t.hasIndexColumn)?t.hasIndexColumn:!1;return l&&(u=o.shift()),p&&(a=o.map(y=>y.shift()),u&&u.shift()),o=new w(o),u&&(o.columns=u),a&&(o.index=a),o}get shape(){return v(this.values)}get rows(){return this.index}set rows(e){let t=this;t.index=e}isEmpty(){return jr(this.values).filter(t=>!x(t)).length===0}clear(){let e=this,t=new w(Xu(e.shape));return t.columns=e.columns.slice(),t.index=e.index.slice(),t}get(e,t){let r=this;(I(e)||P(e))&&(e=[e]),(I(t)||P(t))&&(t=[t]);let s=jr((e||[]).concat(t||[]).map(o=>typeof o));return f(s.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),s.length===1&&f(s[0]==="string"||s[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),s.length===2&&(f(s.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),f(s.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),x(e)||(e=e.map(o=>{if(typeof o=="string")return f(r.index.indexOf(o)>-1,`Row "${o}" does not exist!`),o;if(typeof o=="number")return f(o>=0,`Index ${o} is out of bounds!`),f(parseInt(o)===o,"Row numbers must be integers!"),f(o<r.index.length,`Index ${o} is out of bounds!`),r.index[o]})),x(t)||(t=t.map(o=>{if(typeof o=="string")return f(r.columns.indexOf(o)>-1,`Column "${o}" does not exist!`),o;if(typeof o=="number")return f(o>=0,`Column ${o} is out of bounds!`),f(parseInt(o)===o,"Column numbers must be integers!"),f(o<r.columns.length,`Column ${o} is out of bounds!`),r.columns[o]})),r.getSubsetByNames(e,t)}getSubsetByNames(e,t){let r=this;x(e)&&(e=r.index),x(t)&&(t=r.columns),typeof e=="string"&&(e=[e]),typeof t=="string"&&(t=[t]),f(O(e)&&O(t),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),f(v(e).length===1&&v(t).length===1,"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),f(e.length>0,"The `rows` array must contain at least one row name."),f(t.length>0,"The `cols` array must contain at least one column name."),e.forEach(i=>{f(I(i),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),f(r.index.indexOf(i)>-1,`The row name "${i}" does not exist in the list of rows.`)}),t.forEach(i=>{f(I(i),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),f(r.columns.indexOf(i)>-1,`The column name "${i}" does not exist in the list of columns.`)});let s=e.map(i=>t.map(u=>r.values[r.index.indexOf(i)][r.columns.indexOf(u)]));if(e.length===1&&t.length===1)return $(s)[0];if(e.length===1){let i=new S($(s));return i.name=e[0],i.index=t,i}if(t.length===1){let i=new S($(s));return i.name=t[0],i.index=e,i}let o=new w(s);return o.columns=t,o.index=e,o}getSubsetByIndices(e,t){let r=this,s=r.shape;x(e)&&(e=M(0,s[0])),x(t)&&(t=M(0,s[1])),typeof e=="number"&&(e=[e]),typeof t=="number"&&(t=[t]),f(O(e)&&O(t),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),f(v(e).length===1&&v(t).length===1,"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),f(e.length>0,"The `rowIndices` array must contain at least one index."),f(t.length>0,"The `colIndices` array must contain at least one index."),e.forEach(u=>{f(Ue(u),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),f(u<r.index.length,`The row index ${u} is out of bounds.`)}),t.forEach(u=>{f(Ue(u),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),f(u<r.columns.length,`The column index ${u} is out of bounds.`)});let o=e.map(u=>r.index[u]),i=t.map(u=>r.columns[u]);return r.getSubsetByNames(o,i)}loc(e,t){return this.getSubsetByNames(e,t)}iloc(e,t){return this.getSubsetByIndices(e,t)}transpose(){let e=this,t=new w(de(e.values));return t.columns=e.index,t.index=e.columns,t}get T(){return this.transpose()}resetIndex(){let e=this,t=e.copy();return t.index=M(0,e.shape[0]).map(r=>"row"+ke(r,(t.index.length-1).toString().length)),t}copy(){let e=this;if(e.isEmpty())return new w;let t=new w(Y(e.values));return t.columns=e.columns.slice(),t.index=e.index.slice(),t}assign(e,t){let r,s;x(t)?(s=e,f(!O(s),"When using only one parameter for the `assign` method, the parameter must be an object or a Series.")):(r=e,s=t,f(I(r),"When using two parameters for the `assign` method, the first parameter must be a string."),f(ne(s)||O(s)&&v(s).length===1,"When using two parameters for the `assign` method, the second parameter must be a Series or a 1-dimensional array.")),f(Zu(s)||ne(s)||O(s)&&v(s).length===1,"An object, Series, or 1-dimensional array must be passed into the `assign` method.");let o=this;if(ne(s)){let i={};return f(o.isEmpty()||Sr(s.index,o.index),"The index of the new data does not match the index of the DataFrame."),i[r||s.name]=s.values,o.assign(i)}else if(O(s)){let i={};return i[r||"data"]=s,o.assign(i)}else{let i=o.copy(),u=i.shape;return Object.keys(s).forEach(a=>{let l=s[a];if(f(O(l),"Each key-value pair must be (respectively) a string and a 1-dimensional array of values."),f(v(l).length===1,"Each key-value pair must be (respectively) a string and a 1-dimensional array of values."),i.isEmpty())i.values=de([l]),i.columns=[a],u=i.shape;else{f(l.length===u[0],`Column "${a}" in the new data is not the same length as the other columns in the original DataFrame.`);let p=i.columns.indexOf(a);p<0&&(i.columns.push(a),p=i.columns.indexOf(a)),i.values.forEach((y,_)=>{y[p]=l[_]})}}),i}}apply(e,t){t=t||0,f(Mr(e),"The first parameter to the `apply` method must be a function."),f(t===0||t===1,"The second parameter to the `apply` method (the `axis`) must be 0 or 1.");let r=this;if(t===0){let o=de(r.values).map((i,u)=>{let a=new S(i);return a.name=r.columns[u],a.index=r.index,e(a,u,r)});if(v(o).length===1){let i=new S(o);return i.index=Y(r.columns),i}else{let i=new w(de(o));return i.index=Y(r.index),i.columns=Y(r.columns),i}}else if(t===1){let s=r.values.map((o,i)=>{let u=new S(o);return u.name=r.index[i],u.index=r.columns,e(u,i,r)});if(v(s).length===1){let o=new S(s);return o.index=Y(r.index),o}else{let o=new w(s);return o.index=Y(r.index),o.columns=Y(r.columns),o}}}map(e,t){return this.apply(e,t)}dropMissing(e,t,r){e=e||0,f(e===0||e===1,"The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1."),r=r||0,f(Ue(r),"The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values)."),t=r>0?"none":t||"any",f(t==="any"||t==="all"||t==="none","The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped).");function s(a){if(r>0){let l=0;for(let p=0;p<a.length;p++){let y=a[p];if(x(y)&&l++,l>=r)return[]}}else if(t==="any")for(let l=0;l<a.length;l++){let p=a[l];if(x(p))return[]}else if(t==="all"){for(let l=0;l<a.length;l++){let p=a[l];if(!x(p))return a}return[]}return a}let i=this.copy(),u=Math.random().toString();if(e===0){i=i.assign(u,i.index);let a=i.values.map(s).filter(p=>p.length>0);if(v(a).length<2)return new w;i.values=a;let l=i.get(null,u);if(x(l))return new w;I(l)&&(l=[l]),ne(l)&&(l=l.values),i.index=l,i=i.drop(null,u)}else if(e===1){i=i.transpose(),i=i.assign(u,i.index);let a=i.values.map(s).filter(p=>p.length>0);if(v(a).length<2)return new w;i.values=a;let l=i.get(null,u);if(x(l))return new w;I(l)&&(l=[l]),ne(l)&&(l=l.values),i.index=l,i=i.drop(null,u),i=i.transpose()}return i}dropNaN(e,t,r){e=e||0,f(e===0||e===1,"The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1."),r=r||0,f(Ue(r),"The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values)."),t=r>0?"none":t||"any",f(t==="any"||t==="all"||t==="none","The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped).");function s(a){let l=Du(a);return r>0?a.length-l.length<r:t==="any"?l.length===a.length:t==="all"?l.length>0:!0}let i=this.copy(),u=Math.random().toString();if(e===0){let a=i.index.filter(l=>{let p=i.get(l,null).values;return s(p)});return a.length>0?i.get(a,null):new w}else if(e===1){let a=i.columns.filter(l=>{let p=i.get(null,l).values;return s(p)});return a.length>0?i.get(null,a):new w}return i}drop(e,t){let r=this;x(e)&&(e=[]),x(t)&&(t=[]),(I(e)||P(e))&&(e=[e]),(I(t)||P(t))&&(t=[t]),f(O(e),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),f(O(t),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),f(v(e).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),f(v(t).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");let s,o;r.index.forEach((u,a)=>{e.indexOf(u)<0&&e.indexOf(a)<0&&(s||(s=[]),s.push(u))}),r.columns.forEach((u,a)=>{t.indexOf(u)<0&&t.indexOf(a)<0&&(o||(o=[]),o.push(u))});let i=r.get(s,o);if(ne(i)){let u=new w;u=u.assign(i),r.index.indexOf(i.name)>-1&&(u=u.transpose()),i=u}return i}dropColumns(e){return this.drop(null,e)}dropRows(e){return this.drop(e,null)}toObject(){let e=this,t={};return e.values.forEach((r,s)=>{let o={};r.forEach((i,u)=>{o[e.columns[u]]=i}),t[e.index[s]]=o}),t}toCSVString(e){let t=this;e=x(e)?{}:e;let r=H(e.hasHeaderRow)?e.hasHeaderRow:!0,s=H(e.hasIndexColumn)?e.hasIndexColumn:!1,o,i,u;return r&&s?(o=["(index)"].concat(Y(t.index)),i=Y(t.columns),u=[i].concat(t.values).map((a,l)=>[o[l]].concat(a))):!r&&s?(o=Y(t.index),u=t.values.map((a,l)=>[o[l]].concat(a))):r&&!s?(i=Y(t.columns),u=[i].concat(t.values)):!r&&!s&&(u=t.values),u=u.map((a,l)=>a.map(p=>I(p)?ea(p):p).join(",")).join(`
`),u}toCSV(e,t){let r=this,s=r.toCSVString(t);try{let o=e;if(e.includes("/")){let u=e.split("/");o=u[u.length-1]}let i=document.createElement("a");i.href=`data:text/csv;charset=utf-8,${encodeURIComponent(s)}`,i.download=o,i.dispatchEvent(new MouseEvent("click"))}catch{}try{let o=He("fs"),i=He("path");o.writeFileSync(i.resolve(e),s,"utf8")}catch{}return r}print(){let e=this;if(Sr(e.shape,[0]))return console.table({}),e;let t=typeof window=="undefined"?20:10,r=parseInt(t/2),s=typeof window=="undefined"?Math.floor(process.stdout.columns/24)-1:10,o=parseInt(s/2),i=t>e.index.length?null:M(0,r).concat(M(e.index.length-r,e.index.length)),u=s>e.columns.length?null:M(0,o).concat(M(e.columns.length-o,e.columns.length)),a=e.get(i,u);return a instanceof S&&(e.shape[0]===1?(a=new w([a.values]),a.index=e.index,a.columns=new S(e.columns).get(u).values):e.shape[1]===1&&(a=new w([a.values]).transpose(),a.index=new S(e.index).get(i).values,a.columns=e.columns)),t<=e.index.length&&(a._index.splice(r,0,"..."),a._values.splice(r,0,M(0,a.columns.length).map(l=>"..."))),s<=e.columns.length&&(a._columns.splice(o,0,"..."),a._values=a._values.map(l=>(l.splice(o,0,"..."),l))),console.table(a.toObject()),e}sort(e,t){let s=this.copy(),o=Hu().toString();return s=s.assign(o,s.index),x(e)&&(e=[o],t=[!0]),(P(e)||I(e))&&(e=[e],(H(t)||I(t))&&(t=[t])),f(O(e),"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),f(v(e).length===1,"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),x(t)&&(t=M(0,e.length).map(i=>!0)),f(O(t),"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),f(v(t).length===1,"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),f(e.length===t.length,"The arrays passed into the `sort` method must be equal in length."),e=e.map(i=>{if(f(I(i)||P(i),"Column references can either be column names (as strings) or column indices (as whole numbers)."),I(i)){let u=s.columns.indexOf(i);return f(u>-1,`The column "${i}" does not exist!`),u}if(P(i))return f(parseInt(i)===i,"Column indices must be whole numbers!"),f(i>=0,`The column index ${i} is out of bounds!`),f(i<s.columns.length,`The index ${i} is out of bounds!`),i}),t=t.map(i=>{if(f(I(i)||H(i),"Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),I(i)){let u=i.trim().toLowerCase();return f(u==="ascending"||u==="descending","Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),u==="ascending"}if(H(i))return i}),s.values=Gu(s.values,(i,u)=>{let a=0;for(;i[e[a]]===u[e[a]]&&a<e.length;)a++;let l=t[a];if(i[e[a]]===u[e[a]])return 0;if(i[e[a]]<u[e[a]])return l?-1:1;if(i[e[a]]>u[e[a]])return l?1:-1}),s.index=$(s.get(null,o).values),s=s.dropColumns(o),s}sortByIndex(){return this.sort()}filter(e,t){f(Mr(e),"The `filter` method takes a single parameter: a function that is used to filter the values."),x(t)&&(t=0),f(t===0||t===1,"The `axis` parameter to the `filter` method must be 0 or 1.");let r=this,s=r.copy();if(s.isEmpty())return s;let o=Yr(s.index),i=Yr(s.columns);if(t===0){let u=s.values.filter((a,l)=>{let p=new S(a);p.name=r.index[l],p.index=r.columns;let y=e(p,l,r);return y||delete o[s.index[l]],y});if($(u).length===0)return new w;if(u.length===1){let a=new S($(u));return a.name=re(o)[0],a.index=re(i),a}s.values=u,s.index=re(o)}else if(t===1){s=s.transpose();let u=s.values.filter((a,l)=>{let p=new S(a);p.name=r.columns[l],p.index=r.index;let y=e(p,l,r);return y||delete i[s.index[l]],y});if($(u).length===0)return new w;if(u.length===1){let a=new S($(u));return a.name=re(i)[0],a.index=re(o),a}s.values=u,s.index=re(i),s=s.transpose()}return s}shuffle(e){x(e)&&(e=0),f(e===0||e===1,"The `axis` parameter to the `shuffle` must be 0, 1, or undefined.");let t=this;return t.get(e===0?shuffle(t.index):null,e===1?shuffle(t.columns):null)}};Ur.exports=w});var Pr=c((Ef,$r)=>{var kr=m(),zr=d(),Cr=T();function ta(n,e){kr(zr(n),"You must pass two arrays into the `diff` function!"),kr(zr(e),"You must pass two arrays into the `diff` function!");let t=Cr(n),r=Cr(e),s=[];return t.forEach(o=>{r.indexOf(o)<0&&s.push(o)}),s}$r.exports=ta});var ze=c((If,_r)=>{var Vr=h(),na=b();function ra(n,e){try{return Vr(n)?Vr(e)?Math.pow(n,e):NaN:NaN}catch{return NaN}}_r.exports=na(ra)});var Ce=c((Sf,Br)=>{var sa=oe(),oa=T();function ia(n){try{return sa(...oa(n))}catch{return NaN}}Br.exports=ia});var ft=c((Mf,Rr)=>{var ua=h(),aa=b();function ca(){try{let n=1,e=Object.values(arguments);for(let t=0;t<e.length;t++){if(!ua(e[t]))return NaN;n*=e[t]}return n}catch{return NaN}}Rr.exports=aa(ca)});var se=c((jf,Jr)=>{var la=ft();function fa(n,e){return la(n,e)}Jr.exports=fa});var ht=c((Yf,Kr)=>{var ha=oe(),ma=se();function da(n,e){return ha(n,ma(e,-1))}Kr.exports=da});var Wr=c((Uf,Lr)=>{var pa=ze(),ga=Ce(),ya=Te(),qa=ht();function ba(n,e){try{return ya(ga(pa(qa(n,e),2)))}catch{return NaN}}Lr.exports=ba});var Dr=c((kf,Hr)=>{var Na=se(),wa=ze();function xa(n,e){return Na(n,wa(e,-1))}Hr.exports=xa});var mt=c((Cf,es)=>{var ge=m(),Fr=g(),Xr=d(),va=h(),zf=F(),Gr=T(),Qr=A(),Ta=Ce(),Oa=se(),Zr=D();function $e(n,e){ge(!Fr(n)&&!Fr(e),"You must pass two arrays of numbers into the `dot` function!"),ge(Xr(n)&&Xr(e),"You must pass two arrays of numbers into the `dot` function!"),Gr(n).concat(Gr(e)).forEach(s=>{ge(va(s),"One of the arrays you passed into the `dot` function contains non-numerical values!")});let t=Qr(n),r=Qr(e);if(ge(t.length<=2&&r.length<=2,"I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!"),ge(t[t.length-1]===r[0],`There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${t[t.length-1]} !== ${r[0]})`),t.length===1&&r.length===1)return Ta(Oa(n,e));if(t.length===1&&r.length===2)return Zr(e).map(s=>$e(n,s));if(t.length===2&&r.length===1)return n.map(s=>$e(s,e));if(t.length===2&&r.length===2){let s=Zr(e),o=[];for(let i=0;i<n.length;i++){let u=[];for(let a=0;a<s.length;a++)u.push($e(n[i],s[a]));o.push(u)}return o}}es.exports=$e});var rs=c(($f,ns)=>{var ts=m(),Aa=d(),Ea=g(),Ia=A();function Sa(n){return ts(Aa(n),"The value passed into the `dropMissing` function must be a one-dimensional array!"),ts(Ia(n).length===1,"The value passed into the `dropMissing` function must be a one-dimensional array!"),n.filter(e=>!Ea(e))}ns.exports=Sa});var cs=c((Pf,as)=>{var ss=m(),os=g(),is=d(),Ma=B(),us=A();function ja(n,e){ss(is(n)&&is(e),"The two items passed into the `dropMissingPairwise` function must be arrays!"),ss(us(n).length===1&&us(e).length===1,"The `dropMissingPairwise` function only works on one-dimensional arrays!");let t=[],r=[];for(let s=0;s<Ma([n.length,e.length]);s++)!os(n[s])&&!os(e[s])&&(t.push(n[s]),r.push(e[s]));return[t,r]}as.exports=ja});var gs=c((Vf,ps)=>{var ls=m(),fs=g(),hs=d(),ms=h(),Ya=B(),ds=A();function Ua(n,e){ls(hs(n)&&hs(e),"The two items passed into the `dropNaNPairwise` function must be arrays!"),ls(ds(n).length===1&&ds(e).length===1,"The `dropNaNPairwise` function only works on one-dimensional arrays!");let t=[],r=[];for(let s=0;s<Ya([n.length,e.length]);s++)!fs(n[s])&&ms(n[s])&&!fs(e[s])&&ms(e[s])&&(t.push(n[s]),r.push(e[s]));return[t,r]}ps.exports=Ua});var qs=c((_f,ys)=>{var ka=b(),za=h();function Ca(n){try{return za(n)?Math.exp(n):NaN}catch{return NaN}}ys.exports=ka(Ca)});var ws=c((Bf,Ns)=>{var $a=b();function bs(n){try{return n!==parseInt(n)?NaN:n<=1?1:n*bs(n-1)}catch{return NaN}}Ns.exports=$a(bs)});var vs=c((Rf,xs)=>{var Pa=h(),Va=b();function _a(n){try{let e=JSON.parse(n);return Pa(e)?e:NaN}catch{return NaN}}xs.exports=Va(_a)});var Pe=c((Jf,Ts)=>{var Ba=h(),Ra=b();function Ja(n){try{return Ba(n)?Math.floor(n):NaN}catch{return NaN}}Ts.exports=Ra(Ja)});var dt=c((Kf,Os)=>{var Ka=h(),La=b();function Wa(n){try{let e=JSON.parse(n);return Ka(e)?parseInt(e):NaN}catch{return NaN}}Os.exports=La(Wa)});var Is=c((Lf,Es)=>{var J=m(),Ha=g(),pt=d(),gt=h(),As=A(),Da=dt();function yt(n,e){return J(!Ha(n),"You must pass an array and an index into the `getValueAt` function!"),J(pt(n),"You must pass an array and an index into the `getValueAt` function!"),J(gt(e)||pt(e),"The index passed into the `getValueAt` function must be a positive integer or a one-dimensional array of positive integers!"),pt(e)&&(J(As(e).length===1,"The index passed into the `getValueAt` function must be a positive integer or a one-dimensional array of positive integers!"),e.forEach(t=>{J(gt(t)&&Da(t)===t,"The index passed into the `getValueAt` function must be a positive integer or a one-dimensional array of positive integers!")}),J(e.length<=As(n).length,"The index passed into the `getValueAt` function has too many dimensions!")),gt(e)?(J(e<n.length,`The index ${e} is out of bounds!`),n[e]):e.length>1?(J(e[0]<n.length,`The index ${e[0]} is out of bounds!`),yt(n[e[0]],e.slice(1))):yt(n,e[0])}Es.exports=yt});var qt=c((Df,Ss)=>{var Wf=k(),Hf=z(),Fa=h(),Xa=G();function Ga(n){Fa(n)&&(n=[n]);let e=[],t=1;n.forEach(r=>t*=r);for(let r=0;r<t;r++)e.push(0);return Xa(e,n)}Ss.exports=Ga});var js=c((Ff,Ms)=>{var Ve=m(),Qa=g(),Za=h(),ec=qt();function tc(n){Ve(!Qa(n),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),Ve(Za(n),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),Ve(parseInt(n)===n,"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),Ve(n>0,"You must pass an integer greater than 0 (representing the size) into the `identity` function!");let e=ec([n,n]);for(let t=0;t<n;t++)e[t][t]=1;return e}Ms.exports=tc});var bt=c((Gf,Ys)=>{var Xf=m(),nc=L();function rc(){return nc([...arguments])}Ys.exports=rc});var ks=c((Qf,Us)=>{var sc=d(),oc=T(),ic=bt();function uc(){let n=Object.values(arguments).map(r=>sc(r)?oc(r):[r]),e=[];return ic(n).forEach(r=>{for(let s=0;s<n.length;s++)if(n[s].indexOf(r)<0)return;e.push(r)}),e}Us.exports=uc});var wt=c((eh,$s)=>{var ye=m(),_e=g(),zs=h(),Nt=d(),ac=Z(),cc=T(),Zf=A(),lc=Pe();function Cs(n,e){if(ye(!_e(n),"You must pass an array into the `slice` function!"),ye(Nt(n),"You must pass an array into the `slice` function!"),_e(e))return n.slice();ye(Nt(e),"The indices passed into the `slice` function must be a one-dimensional array of integers or null values."),cc(e).forEach(s=>{ye(_e(s)||zs(s)&&lc(s)===s,"The indices passed into the `slice` function must be a one-dimensional array of integers or null values.")});let t=e[0];_e(t)&&(t=ac(0,n.length)),zs(t)&&(t=[t]);let r=[];return t.forEach(s=>{ye(s<n.length,"Index out of bounds in the `slice` function!"),s<0&&(s+=n.length);let o=n[s];Nt(o)?r.push(Cs(n[s],e.slice(1,e.length))):r.push(n[s])}),r}$s.exports=Cs});var Bs=c((th,_s)=>{var V=m(),fc=g(),hc=d(),xt=h(),mc=T(),dc=A(),Be=wt(),pc=mt(),Ps=oe(),Vs=se(),vt=Ze(),K=Z();function Tt(n){V(!fc(n),"You must pass a square 2D array into the `inverse` function!"),V(hc(n),"You must pass a square 2D array into the `inverse` function!"),mc(n).forEach(t=>V(xt(t),"The array passed into the `inverse` function must contain only numbers!"));let e=dc(n);if(V(e.length===2,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),V(e[0]===e[1],"The array passed into the `inverse` function must be exactly two-dimensional and square!"),V(e[0]>=0,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),e[0]===0)return n;if(e[0]===1)return V(n[0][0]!==0,"This matrix cannot be inverted!"),1/n[0][0];if(e[0]===2){let t=n[0][0],r=n[0][1],s=n[1][0],o=n[1][1],i=t*o-r*s;V(i!==0,"This matrix cannot be inverted!");let u=[[o,-r],[-s,t]];return Vs(u,1/i)}else if(e[0]>1){let t=(r,s)=>xt(r)||xt(s)?Vs(r,s):pc(r,s);for(let r=1;r<e[0]-1;r++)try{let s=Be(n,[K(0,r),K(0,r)]),o=Be(n,[K(0,r),K(r,e[0])]),i=Be(n,[K(r,e[0]),K(0,r)]),u=Be(n,[K(r,e[0]),K(r,e[0])]),a=Tt(s),l=Tt(Ps(u,t(-1,t(t(i,a),o)))),p=Ps(a,t(t(t(t(a,o),l),i),a)),y=t(-1,t(t(a,o),l)),_=t(-1,t(t(l,i),a)),Ke=l;return vt(vt(p,y,1),vt(_,Ke,1),0)}catch{}V(!1,"This matrix cannot be inverted!")}}_s.exports=Tt});var Js=c((nh,Rs)=>{var gc=d(),yc=g();function qc(n){return typeof n=="object"&&!yc(n)&&!gc(n)}Rs.exports=qc});var Ls=c((rh,Ks)=>{var bc=b(),Ot=h();function Nc(n,e,t){try{return Ot(n)?Ot(e)?Ot(t)?t*(e-n)+n:NaN:NaN:NaN}catch{return NaN}}Ks.exports=bc(Nc)});var Ds=c((sh,Hs)=>{var Ws=h(),wc=g(),xc=b();function vc(n,e){try{return e=wc(e)?Math.E:e,Ws(n)?Ws(e)?Math.log(n)/Math.log(e):NaN:NaN}catch{return NaN}}Hs.exports=xc(vc)});var Xs=c((oh,Fs)=>{var qe=h(),Tc=b();function Oc(n,e,t,r,s){try{return qe(n)?qe(e)?qe(t)?qe(r)?qe(s)?(s-r)*(n-e)/(t-e)+r:NaN:NaN:NaN:NaN:NaN}catch{return NaN}}Fs.exports=Tc(Oc)});var Qs=c((lh,Gs)=>{var ih=m(),uh=g(),ah=d(),ch=h(),Ac=T(),Ec=ee(),Ic=Ee();function Sc(n){try{let e=Ac(n),t=Ic(e);if(t.length===0)return NaN;if(t.length<e.length)return NaN;t=Ec(t);let r;return t.length%2===0?r=(t[t.length/2-1]+t[t.length/2])/2:r=t[Math.floor(t.length/2)],r}catch{return NaN}}Gs.exports=Sc});var to=c((fh,eo)=>{var Mc=T(),jc=Ae(),Yc=L(),Zs=ee();function Uc(n){try{if(n.length===0)return NaN;let e=Mc(n);if(e.length===0)return NaN;let t={},r=Yc(e);r.forEach(u=>{t[u]=jc(e,u)});let s=Zs(r,(u,a)=>t[a]-t[u]),o=s[0],i=Zs(s.filter(u=>t[u]===t[o]));return i.length===1?i[0]:i}catch{return NaN}}eo.exports=Uc});var oo=c((dh,so)=>{var kc=g(),hh=k(),mh=z(),{random:no}=Q(),zc=G(),Cc=h();function ro(){let n=no(),e=no();return Math.sqrt(-2*Math.log(n))*Math.cos(2*Math.PI*e)}function $c(n){if(kc(n))return ro();Cc(n)&&(n=[n]);let e=[],t=1;n.forEach(r=>t*=r);for(let r=0;r<t;r++)e.push(ro());return zc(e,n)}so.exports=$c});var uo=c((yh,io)=>{var ph=k(),gh=z(),Pc=G(),Vc=h();function _c(n){Vc(n)&&(n=[n]);let e=[],t=1;n.forEach(r=>t*=r);for(let r=0;r<t;r++)e.push(1);return Pc(e,n)}io.exports=_c});var lo=c((qh,co)=>{var ao=d(),Bc=h(),Re=m(),Rc=g();function At(n,e){if(Re(ao(n),"The `permute` function only works on arrays!"),Rc(e)&&(e=n.length),Re(Bc(e),"`r` must be a whole number!"),e>n.length)return At(n);if(e<=0)return[[]];if(Re(e===parseInt(e),"`r` must be a whole number!"),n.length<2)return n;let t=[];return n.forEach((r,s)=>{Re(!ao(r),"It is not recommended to permute arrays of arrays. Weird things happen, and I haven't figured out how to account for such a scenario yet. A possible workaround is: convert each sub-array to a string (using `JSON.stringify`), get the permutations using the array of strings, and then convert each string in each combination back to a sub-array (using `JSON.parse`).");let o=n.slice(0,s),i=n.slice(s+1),u=o.concat(i);At(u,e-1).forEach(l=>{t.push([r].concat(l))})}),t}co.exports=At});var po=c((bh,mo)=>{var Jc=d(),Kc=A(),fo=lt(),ho=Ye();function Lc(){Object.keys(arguments).forEach(n=>{let e=arguments[n];if(Jc(e)){let t=Kc(e);t.length===1?new ho(e).print():t.length==2?new fo(e).print():console.log(e)}else e instanceof fo||e instanceof ho?e.print():console.log(e)})}mo.exports=Lc});var yo=c((Nh,go)=>{var Wc=h(),Hc=b();function Dc(n){try{return Wc(n)?Math.round(n):NaN}catch{return NaN}}go.exports=Hc(Dc)});var Et=c((wh,No)=>{var qo=m(),Fc=h(),bo=d(),Xc=X();function Gc(n,e,t){qo(bo(n),"The first argument passed into the `setValueAt` function must be an array!"),Fc(e)&&(e=[e]),qo(bo(e),"The second argument passed into the `setValueAt` function must be an integer or an array of integers!");let r=Xc(n),s=r;for(let o=0;o<e.length-1;o++)s=s[e[o]];return s[e[e.length-1]]=t,r}No.exports=Gc});var vo=c((vh,xo)=>{var wo=m(),Qc=g(),Zc=d(),xh=Pe(),{random:el}=Q();function tl(n){wo(!Qc(n),"You must pass an array into the `shuffle` function!"),wo(Zc(n),"You must pass an array into the `shuffle` function!");let e=[],t=n.slice();for(let r=0;r<n.length;r++){let s=parseInt(el()*t.length);e.push(t.splice(s,1)[0])}return e}xo.exports=tl});var Oo=c((Th,To)=>{var nl=h(),rl=b();function sl(n){try{return nl(n)?n<0?-1:n>0?1:0:NaN}catch{return NaN}}To.exports=rl(sl)});var Eo=c((Oh,Ao)=>{var ol=h(),il=b();function ul(n){try{return ol(n)?Math.sin(n):NaN}catch{return NaN}}Ao.exports=il(ul)});var So=c((Ah,Io)=>{var al=Oe();function cl(n){return al(n)}Io.exports=cl});var jo=c((Eh,Mo)=>{var ll=h(),fl=b();function hl(n){try{return ll(n)?Math.tan(n):NaN}catch{return NaN}}Mo.exports=fl(hl)});var Je=c((Ih,Uo)=>{var Yo=R();function ml(n,e){assert(Yo(n),"`fn` must be a function!");let t=new Date;return e?n(...e):n(),new Date-t}async function dl(n,e){assert(Yo(n),"`fn` must be a function!");let t=new Date;return e?await n(...e):await n(),new Date-t}Uo.exports={timeSync:ml,timeAsync:dl}});var Co=c((Sh,zo)=>{var ko=m(),pl=d(),gl=R(),yl=z(),ql=ce(),bl=Et(),Nl=T();function wl(n,e){ko(pl(n),"The first argument passed into the `where` function must be an array!"),ko(gl(e),"The second argument passed into the `where` function must be a function!");let t=Nl(n).length,r=yl(n,e),s=[],o=0,i=!1;for(;!i;){let u=ql(r,!0);u?(s[o]=u,r=bl(r,u,null),o++):i=!0}return o===0?null:s}zo.exports=wl});var xl=c((Mh,It)=>{var be={abs:Xe(),add:oe(),append:Ze(),apply:z(),arccos:sn(),arcsin:un(),arctan:cn(),argmax:qn(),argmin:wn(),assert:m(),ceil:vn(),chop:An(),clamp:In(),cohensd:kn(),combine:Pn(),copy:X(),correl:Hn(),cos:Fn(),count:Ae(),covariance:rt(),DataFrame:lt(),diff:Pr(),distance:Wr(),divide:Dr(),dot:mt(),dropMissing:rs(),dropMissingPairwise:cs(),dropNaN:Ee(),dropNaNPairwise:gs(),exp:qs(),factorial:ws(),flatten:T(),float:vs(),floor:Pe(),getValueAt:Is(),identity:js(),indexOf:ce(),int:dt(),intersect:ks(),inverse:Bs(),isArray:d(),isBoolean:Ie(),isEqual:F(),isFunction:R(),isNumber:h(),isObject:Js(),isString:Se(),isUndefined:g(),lerp:Ls(),log:Ds(),map:Xs(),max:B(),mean:le(),median:Qs(),min:we(),mode:to(),multiply:ft(),ndarray:k(),normal:oo(),ones:uo(),permute:lo(),pow:ze(),print:po(),random:Q().random,range:Z(),reshape:G(),reverse:ie(),round:yo(),scale:se(),seed:Q().seed,Series:Ye(),set:L(),setValueAt:Et(),shape:A(),shuffle:vo(),sign:Oo(),sin:Eo(),slice:wt(),sort:ee(),sqrt:Te(),std:Oe(),stdev:So(),subtract:ht(),sum:Ce(),tan:jo(),time:Je().timeSync,timeSync:Je().timeSync,timeAsync:Je().timeAsync,transpose:D(),union:bt(),variance:xe(),vectorize:b(),where:Co(),zeros:qt(),dump:function(){Object.keys(be).forEach(n=>{typeof global!="undefined"&&(global[n]=be[n]),typeof window!="undefined"&&(window[n]=be[n])})}};typeof It!="undefined"&&(It.exports=be);typeof window!="undefined"&&(window.JSMathTools=be)});xl();})();
